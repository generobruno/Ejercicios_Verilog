module UART_INTERFACE#(
    N   =   8,
    PC  =   32,     // Numbrer of addres bits for Inst mem    
    W   =   5       // Number of address bits for reg mem
)(
        input wire i_clock, 
        input wire i_reset,
        input wire [N-1:0] i_data,
        input wire i_available_data,
        input wire i_fifo_empty,
        input wire [N-1:0 ] i_result,
        input wire [32-1:0] i_reg_read;
        output wire [32-1:0] o_inst,
        output wire [N-1:0] o_result,
        output wire o_write_mem,
        output wire [PC-1 : 0] o_addr,
        output wire [w-1] o_addr_ID;    
        
        
        output wire o_wr,
        output wire o_rd
        
    );
    
    reg [2:0]           counter;
    reg [2:0]           counter_next;
    reg [2:0]           cont;
    reg [2:0]           cont_next;
    reg [W-1:0]         reg_counter;
    reg [W-1:0]         reg_counter_next;
    reg [32-1:0]        inst_reg;
    reg [32-1:0]        inst_reg_next;
    reg [N-1: 0]        to_tx_fifo;
    reg [N-1: 0]        to_tx_fifo_next;
    reg                 write_mem_reg;
    reg                 write_mem_reg_next;
    reg [8-1: 0]        mode_reg;
    reg [8-1: 0]        mode_reg_next;
    reg [8-1: 0]        prog_size_reg;
    reg [8-1: 0]        prog_size_reg_next;
    reg [8-1: 0]        inst_n;                //Number of instructions received
    reg [8-1: 0]        inst_n_next;
    reg [PC-1: 0]       addr_reg;
    reg [PC-1: 0]       addr_reg_next;
    reg [W-1: 0]        addr_ID_reg;
    reg [W-1: 0]        addr_ID_reg_next;

    /* Codigos para modo de funcionamiento */
    localparam REC_PROG         = 11111111;
    localparam LOAD_PROG_SIZE   = 11111110;
    localparam LOAD_PROG        = 11111101;
    localparam DEBUG            = 11111100;
    localparam SEND_STATE       = 11111011;
    localparam NEXT             = 00000001;
    localparam WAIT             = 00000000;

    
    
    
    


    assign o_result = to_tx_fifo;
    assign o_inst = inst_reg;
    assign o_write_mem = write_mem_reg
    assign o_addr = addr_reg;
    assign o_addr_ID = addr_ID_reg;
    
    assign o_rd = rd_reg;
    assign o_wr = wr_reg; 
    
    
    always @(posedge i_clock, posedge i_reset)begin
        if(i_reset)begin
            inst_reg <= {32{1'b0}};
            to_tx_fifo <= {N{1'b0}};
            rd_reg <= 1'b0;
            wr_reg <= 1'b0;
            counter <= {3{1'b0}};
            reg_counter <= {W{1'b0}};
            mode_reg <= {8{1'b0}};
            write_mem_reg <= 1'b0;
            cont <= {3{1'b0}};
            prog_size_reg <= {8{1'b0}};
            inst_n <= {8{1'b0}};
            addr_reg <= {32{1'b0}};
            addr_ID_reg <= {W{1'b0}};
        end
        else begin
            inst_reg <= inst_reg_next;
            counter <= counter_next;
            cont <= cont_next;
            to_tx_fifo <= to_tx_fifo_next;
            mode_reg <= mode_reg_next;
            write_mem_reg <= write_mem_reg_next;
            prog_size_reg <= prog_size_reg_next;
            inst_n <= inst_n_next;
            addr_reg <= addr_reg_next;
            addr_ID_reg <= addr_ID_reg_next;
            reg_counter <= reg_counter_next;
        end
        
    end
    
    always@(*)begin
         
         inst_reg_next = inst_reg;
         counter_next = counter;
         cont_next = cont;
         rd_reg_next = rd_reg;
         wr_reg_next = wr_reg;
         to_tx_fifo_next = to_tx_fifo;
    
    
         if(!i_fifo_empty)begin
                
                wr_reg_next = 1'b0;
                write_mem_reg_next = 1'b0;
                if(mode_reg == START)begin
                    mode_reg_next = i_data;
                end
                else if(mode_reg == REC_PROG)begin
                    rd_reg_next = 1'b1;
                    mode_reg_next <= LOAD_PROG_SIZE;
                 end
                 else if(mode_reg == LOAD_PROG_SIZE)begin
                    rd_reg_next = 1'b1;
                    prog_size_reg_next <= i_data;
                    mode_reg_next <= LOAD_PROG;
                 end
                 else if(mode_reg == LOAD_PROG)begin
                    rd_reg_next = 1'b1;
                    if(inst_n == prog_size_reg)begin
                        mode_reg_next = START;
                        inst_n_next = 8'b00000000;
                    end
                    else if(counter < 4)begin
                        mode_reg_next <= LOAD_PROG_SIZE;
                        inst_reg_next[8*(counter)+:8] = i_data;
                        counter_next = counter +1;
                    end
                    else if(counter == 4)begin
                        rd_reg_next = 1'b0;
                        write_mem_reg_next = 1'b1;
                        addr_reg_next = addr_reg +1;
                        counter_next = 3'b000;
                        inst_n_next = inst_n + 1;
                        mode_reg_next = WAIT;
                        cont_next = mode_reg;
                    end
                 end
                 else if(mode_reg == DEBUG)begin
                    if(i_data == NEXT)begin
                        //TBA como seÃ±alar a la pipeline que prosiga
                        mode_reg_next = SEND_STATE;
                    end
                 end
                 else if(mode_reg == WAIT)begin
                    rd_reg_next = 1'b1;
                            
                    mode_reg_next = cont;
                 end
        end
        if(mode_reg == SEND_STATE)begin
            rd_reg_next = 1'b0;
            if(reg_counter < 31)begin
                addr_ID_reg_next = reg_counter+1;
                reg_counter_next = reg_counter+1;
                to_tx_fifo_next = i_reg_read;
                wr_reg_next = 1'b1;
            end
            else begin
                reg_counter_next = 5'b00000;
                mode_reg_next = DEBUG;
            end
        end

        else
        begin
            if(counter<4)begin
                rd_reg_next = 1'b0;
                counter_next = 3'b101;
            end
            end
            if(counter == 4)begin
                rd_reg_next = 1'b0;
                to_tx_fifo_next = i_result;
                write_mem_reg_next = 1'b1;
                wr_reg_next = 1'b1;
                counter_next = 3'b100;
                cont_next = 3'b000;
            end
    
    end
    
    
    
endmodule
